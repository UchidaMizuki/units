% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_units.R
\name{make_units}
\alias{make_units}
\alias{parse_units}
\alias{set_units}
\alias{symbolic_unit}
\title{Unit creation}
\usage{
make_units(x, allow_user_defined = FALSE,
  auto_convert_names_to_symbols = TRUE)

parse_units(chr, implicit_exponents = FALSE, allow_user_defined = FALSE,
  auto_convert_names_to_symbols = TRUE, auto_backtick = TRUE)

set_units(n, ..., mode = c("symbols", "character", "units"))

symbolic_unit(chr, check_is_parsable = TRUE, user_defined = TRUE,
  auto_convert_name_to_symbol = TRUE)
}
\arguments{
\item{x}{a bare R expression describing units. Must be valid R syntax
(reserved R syntax words like \code{in} must be backticked)}

\item{allow_user_defined}{If FALSE (the default), an error is thrown if any
of the symbols that makeup the units expression are not recognized by the
udunits database. See details.}

\item{auto_convert_names_to_symbols}{Automatically attempt conversion of
names to symbols in the supplied unit expression.}

\item{chr}{a scalar character string describing a unit.}

\item{implicit_exponents}{If the unit string is in product power form (e.g.
\code{"km m-2 s-1"}). Defaults to \code{FALSE}}

\item{auto_backtick}{If \code{TRUE} (the default), symbols in the unit object
are automatically backticked prior to parsing as an R expression. See
details.}

\item{n}{a numeric to be assigned units, or a units object to have units
converted.}

\item{...}{see parameter \code{mode}}

\item{mode}{if \code{"symbols"} (the default), then \code{...} are passed on
to \code{make_units()}. If \code{"character"}, then \code{...} are passed on to
\code{parse_units()}. If \code{"units"}, then \code{...} must be a single
object of class \code{units} or \code{.symbolic_units} and the value is
directly assigned to \code{n} via \code{`units<-`}}

\item{check_is_parsable}{check if the symbolic unit is recognized by the
udunits2 database}

\item{user_defined}{Create a custom unit that is recognized by the udunits2
database. This argument is ignored if `check_is_parsable = FALSE`. If
`check_is_parsable = TRUE` and `user_defined = TRUE`, a warning is issued
in the case of an unrecognized units, otherwise, if `user_defined = FALSE`,
an error is thrown.}

\item{auto_convert_name_to_symbol}{Automatically convert a unit name to it's
symobl. E.g., \code{kilogram} becomes \code{kg}. Note, conversion is not
reliable if the unit name contains a prefixe. This is a limitation of the
underlying \code{udunits2} package and may change in the future.}
}
\value{
A new unit object that can be used in arithmetics
}
\description{
Four functions are provided for creating \code{units} objects: 
\itemize{ 
   \item \code{make_units()} accepts a bare expression: 
         \code{make_units(kg*m/s^2)}
   \item \code{parse_units()} accepts a string: \code{parse_units("kg*m/s^2")}
   \item \code{set_units()} a pipe friendly version of \code{`units<-`}. 
          Has multiple modes of operation, see details.
   \item \code{symbolic_unit()} for creation of a single symbolic unit: 
         \code{symbolic_units("kg")}
   }
}
\details{
In \code{make_units()}, \code{set_units()}, and
  \code{parse_units()}, each of the symbols in the expression is treated as a
  symbolic unit, as returned by \code{symbolic_unit}. By default, each of the
  symbols must be recognized by the udunits database. To see which symbols
  and names are currently recognized by the database, see
  \code{udunits_symbols()}. If \code{allow_user_defined = TRUE} and an
  unrecognized unit is found in the expression, a valid \code{units} object
  is still returned, with a warning. To avoid the warning with user defined
  units, use \code{symbolic_unit(...,user_defined = TRUE)}

If \code{auto_backtick = TRUE} in \code{parse_units()}, symbols are
  automatically backticked prior to parsing the string as an R expression. A
  heuristic is used to perform backticking, such that any continuous set of
  characters uninterrupted by one of \code{()\*^-} are backticked (unless the
  character sequence consists solely of numbers \code{0-9}), with some care
  to not doubleup on pre-existing backticks. For certain expressions, this
  heurestic may give incorrect results.

  If the string supplied to \code{parse_units} failes to parse as an R
  expression (via \code{parse(text = chr)}), then the string is treated as a
  single symbolic unit and \code{symbolic_unit(chr)} is used as a fallback
  with a warning. Note, in that case, automatic unit simplification may not
  work properly when performing operations on unit objects, but unit
  conversion and other Math operations should still give correct results so
  long as the unit string supplied returns \code{TRUE} for
  \code{udunits2::ud.is.parsable()}
}
\examples{
# these calls all return identical objects
# meters per second squared, i.e, acceleration
x1 <- make_units(m/s^2)
x2 <- parse_units("m/s^2")
x3 <- set_units(1,  m/s^2)
x4 <- set_units(1, "m/s^2", mode = "character")
x5 <- set_units(1, x1, mode = "units")
x6 <- set_units(1, units(x1), mode = "units")
x7 <- symbolic_unit("m") / symbolic_unit("s")^2

all_equal <- function(...) {
  l <- list(...)
  for(i in seq_along(l)[-1])
    if(l[[1]] != l[[i]])
      return(FALSE)
  TRUE
}
all_equal(x1, x2, x3, x4, x5, x6, x7)

# Both full unit names or symbols can be used. Arithmetic operations and unit
# conversion between unit objects that were defined as symbols and names will
# work correctly, although unit simplification in printing may not always occur.
x <- 500 * make_units(micrograms/liter)
y <- set_units(200, ug/l)
x + y
x * y # numberic result is correct, but units not simplified

# note, plural form of unit name accepted too ('liters' vs 'liter'), and 
# denominator simplification can is performed correctly 
x * set_units(5, liters)

# unit conversion works too
set_units(x, grams/gallon)

# Creating custom, user defined units
# For example, a microbiologist might work with counts of bacterial cells
# make_units(cells/ml) # by default, throws an ERROR
make_units(cells/ml, allow_user_defined = TRUE) # throws a warning instead
# alternatively, create the custom unit separately
cells <- symbolic_unit("cells", check_is_parsable = FALSE)
ml <- make_units(ml)
cells/ml

# set_units is just a pipe friendly version of `units<-`
set_units(1:5, N/m^2)
if (require(magrittr)) {
 1:5 \%>\% set_units(N/m^2)
 
 # first sets to m, then converts to km
 1:5 \%>\% set_units(m) \%>\% set_units(km) 
}
}
