% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_units.R
\name{make_units}
\alias{make_units}
\alias{parse_units}
\alias{set_units}
\alias{symbolic_unit}
\title{Unit creation}
\usage{
make_units(x, allow_user_defined = FALSE)

parse_units(chr, implicit_exponents = FALSE, allow_user_defined = FALSE,
  auto_backtick = TRUE)

set_units(n, un)

symbolic_unit(chr, check_is_parsable = TRUE, user_defined = TRUE)
}
\arguments{
\item{x}{a bare R expression.}

\item{allow_user_defined}{If FALSE (the default), an error is thrown if any
of the symbols that makeup the units expression are not recognized by the
udunits database. See details.}

\item{chr}{a scalar character string describing a unit.}

\item{implicit_exponents}{If the unit string is in product power form (e.g.
\code{"km m-2 s-1"}). Defaults to \code{FALSE}}

\item{auto_backtick}{If \code{TRUE} (the default), symbols in the unit object
are automatically backticked prior to parsing as an R expression. See
details.}

\item{n}{a numeric to be assigned units, or a units object to have units
converted.}

\item{un}{a units object or a bare expression describing a units object.}

\item{check_is_parsable}{check if the symbolic unit is recognized by the
udunits2 database}

\item{user_defined}{Create a custom unit that is recognized by the udunits2
database. This argument is ignored if `check_is_parsable = FALSE`. If
`check_is_parsable = TRUE` and `user_defined = TRUE`, a warning is issued
in the case of an unrecognized units, otherwise, if `user_defined = FALSE`,
an error is thrown.}
}
\value{
A new unit object that can be used in arithmetics
}
\description{
Four functions are provided for creating \code{units} objects: 
\itemize{ 
   \item \code{make_units()} accepts a bare expression: \code{make_units(kg*m/s^2)}
   \item \code{parse_units()} accepts a string: \code{parse_units("kg*m/s^2")}
   \item \code{set_units()} a pipe friendly version of \code{`units<-`}. Accepts a unit object or a bare expression.
   \item \code{symbolic_unit()} for creation of a single symbolic unit: \code{symbolic_units("kg")}
   }
}
\details{
In \code{make_units()}, \code{set_units()}, and
  \code{parse_units()}, each of the symbols in the expression is treated as a
  symbolic unit, as returned by \code{symbolic_unit}. By default, each of the
  symbols must be recognized by the udunits database. To see which symbols
  and names are currently recognized by the database, see
  \code{udunits_symbols()}. If \code{allow_user_defined = TRUE} and an
  unrecognized unit is found in the expression, a valid \code{units} object
  is still returned, with a warning. To avoid the warning with user defined
  units, use \code{symbolic_unit(...,user_defined = TRUE)}
  
  
   the unit or a part of the unit is
  unrecognized by the udunits2 database that powers the units package.
  Otherwise throws warning. use `symbolic_unit(user_defined = TRUE)` to avoid
  warnings with user defined units
  
  Must be valid R syntax (reserved words like \code{in} must be backticked)

If \code{auto_backtick = TRUE} in \code{parse_units()}, symbols are
  automatically backticked prior to parsing the string as an R expression. A
  heuristic is used to perform backticking, such that any continuous set of
  characters uninterrupted by one of \code{()\*^-} are backticked (unless the
  character sequence consists solely of numbers \code{0-9}), with some care
  to not doubleup on pre-existing backticks. For certain expressions, this
  heurestic may give incorrect results.

  If the string supplied to \code{parse_units} failes to parse as an R
  expression (via \code{parse(text = chr)}), then the string is treated as a
  single symbolic unit and \code{symbolic_unit(chr)} is used as a fallback
  with a warning. Note, in that case, automatic unit simplification may not
  work properly when performing operations on unit objects, but unit
  conversion and other Math operations should still give correct results so
  long as the unit string supplied returns \code{TRUE} for
  \code{udunits2::ud.is.parsable()}

In \code{set_units()}, standard evaluation of the supplied argument
  \code{un} is attempted first. If the result is not a units object, then the
  bare expression that was typed into the function call is used to create a
  new units object. For this reason, using \code{set_units()} with a bare
  expression should be avoided in R packages and other situations where the
  evaluation environemnt isn't always known in advance, because the supplied
  expression may unexpectantly evaluate to a valid object, in which case the
  expression itself will not be used
}
\examples{
# these calls all return identical objects
# meters per second squared, i.e, acceleration
x1 <- make_units(m/s^2)
x2 <- parse_units("m/s^2")
x3 <- set_units(1, m/s^2)
x4 <- set_units(1, x1)
x5 <- set_units(1, units(x1))
x6 <- symbolic_unit("m") / symbolic_unit("s")^2

all_identical <- function(...) {
  l <- list(...)
  for(i in seq_along(l)[-1])
    if(!identical(l[[1]], l[[i]]))
      return(FALSE)
  TRUE
}
all_identical(x1, x2, x3, x4, x5, x6)

# Both full unit names or symbols can be used. Arithmetic operations and unit
conversion between # unit objects that were defined as symbols and names will
work correctly, # although unit simplification in printing may not always occur.
x <- 500 * make_units(micrograms/liter)
y <- set_units(200, ug/l)
x + y
x * y # numberic result is correct, but units not simplified

# note, plural form of unit name accepted too ('liters' vs 'liter'), and 
# denominator simplification can is performed correctly 
x * set_units(5, liters)

# unit conversion works too
set_units(x, grams/gallon)

# Creating custom, user defined units
# For example, a microbiologist might work with counts of bacterial cells
# make_units(cells/ml) # by default, throws an ERROR
make_units(cells/ml, allow_user_defined = TRUE) # throws a warning instead
# alternatively, create the custom unit separately
cells <- symbolic_unit("cells", check_is_parsable = FALSE)
ml <- make_units(ml)
cells/ml

# set_units is just a pipe friendly version of `units<-`
note that these units have NOT been defined or declared before:
set_units(1:5, N/m^2)
set_units(1:5, unitless) # unit "1", unitless
if (require(magrittr)) {
 1:5 \%>\% set_units(N/m^2)
 
 # first sets to m, then converts to km
 1:10 \%>\% set_units(m) \%>\% set_units(km) 
}
}
